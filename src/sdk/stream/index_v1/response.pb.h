// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sdk/stream/index_v1/response.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sdk_2fstream_2findex_5fv1_2fresponse_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_sdk_2fstream_2findex_5fv1_2fresponse_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include "sdk/core/data_interval.pb.h"
#include "sdk/stream/index_v1/commodity.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_sdk_2fstream_2findex_5fv1_2fresponse_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sdk_2fstream_2findex_5fv1_2fresponse_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_sdk_2fstream_2findex_5fv1_2fresponse_2eproto;
namespace kaikosdk {
class StreamIndexServiceResponseBaseAsset;
struct StreamIndexServiceResponseBaseAssetDefaultTypeInternal;
extern StreamIndexServiceResponseBaseAssetDefaultTypeInternal _StreamIndexServiceResponseBaseAsset_default_instance_;
class StreamIndexServiceResponseInstruments;
struct StreamIndexServiceResponseInstrumentsDefaultTypeInternal;
extern StreamIndexServiceResponseInstrumentsDefaultTypeInternal _StreamIndexServiceResponseInstruments_default_instance_;
class StreamIndexServiceResponsePairs;
struct StreamIndexServiceResponsePairsDefaultTypeInternal;
extern StreamIndexServiceResponsePairsDefaultTypeInternal _StreamIndexServiceResponsePairs_default_instance_;
class StreamIndexServiceResponsePercentage;
struct StreamIndexServiceResponsePercentageDefaultTypeInternal;
extern StreamIndexServiceResponsePercentageDefaultTypeInternal _StreamIndexServiceResponsePercentage_default_instance_;
class StreamIndexServiceResponseV1;
struct StreamIndexServiceResponseV1DefaultTypeInternal;
extern StreamIndexServiceResponseV1DefaultTypeInternal _StreamIndexServiceResponseV1_default_instance_;
class StreamIndexServiceUnderlyingTrade;
struct StreamIndexServiceUnderlyingTradeDefaultTypeInternal;
extern StreamIndexServiceUnderlyingTradeDefaultTypeInternal _StreamIndexServiceUnderlyingTrade_default_instance_;
}  // namespace kaikosdk
PROTOBUF_NAMESPACE_OPEN
template<> ::kaikosdk::StreamIndexServiceResponseBaseAsset* Arena::CreateMaybeMessage<::kaikosdk::StreamIndexServiceResponseBaseAsset>(Arena*);
template<> ::kaikosdk::StreamIndexServiceResponseInstruments* Arena::CreateMaybeMessage<::kaikosdk::StreamIndexServiceResponseInstruments>(Arena*);
template<> ::kaikosdk::StreamIndexServiceResponsePairs* Arena::CreateMaybeMessage<::kaikosdk::StreamIndexServiceResponsePairs>(Arena*);
template<> ::kaikosdk::StreamIndexServiceResponsePercentage* Arena::CreateMaybeMessage<::kaikosdk::StreamIndexServiceResponsePercentage>(Arena*);
template<> ::kaikosdk::StreamIndexServiceResponseV1* Arena::CreateMaybeMessage<::kaikosdk::StreamIndexServiceResponseV1>(Arena*);
template<> ::kaikosdk::StreamIndexServiceUnderlyingTrade* Arena::CreateMaybeMessage<::kaikosdk::StreamIndexServiceUnderlyingTrade>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace kaikosdk {

// ===================================================================

class StreamIndexServiceResponsePercentage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kaikosdk.StreamIndexServiceResponsePercentage) */ {
 public:
  inline StreamIndexServiceResponsePercentage() : StreamIndexServiceResponsePercentage(nullptr) {}
  ~StreamIndexServiceResponsePercentage() override;
  explicit PROTOBUF_CONSTEXPR StreamIndexServiceResponsePercentage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamIndexServiceResponsePercentage(const StreamIndexServiceResponsePercentage& from);
  StreamIndexServiceResponsePercentage(StreamIndexServiceResponsePercentage&& from) noexcept
    : StreamIndexServiceResponsePercentage() {
    *this = ::std::move(from);
  }

  inline StreamIndexServiceResponsePercentage& operator=(const StreamIndexServiceResponsePercentage& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamIndexServiceResponsePercentage& operator=(StreamIndexServiceResponsePercentage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamIndexServiceResponsePercentage& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamIndexServiceResponsePercentage* internal_default_instance() {
    return reinterpret_cast<const StreamIndexServiceResponsePercentage*>(
               &_StreamIndexServiceResponsePercentage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(StreamIndexServiceResponsePercentage& a, StreamIndexServiceResponsePercentage& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamIndexServiceResponsePercentage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamIndexServiceResponsePercentage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamIndexServiceResponsePercentage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamIndexServiceResponsePercentage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamIndexServiceResponsePercentage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamIndexServiceResponsePercentage& from) {
    StreamIndexServiceResponsePercentage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamIndexServiceResponsePercentage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kaikosdk.StreamIndexServiceResponsePercentage";
  }
  protected:
  explicit StreamIndexServiceResponsePercentage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPairsFieldNumber = 3,
    kPercentageFieldNumber = 1,
    kPriceFieldNumber = 2,
  };
  // repeated .kaikosdk.StreamIndexServiceResponsePairs pairs = 3;
  int pairs_size() const;
  private:
  int _internal_pairs_size() const;
  public:
  void clear_pairs();
  ::kaikosdk::StreamIndexServiceResponsePairs* mutable_pairs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kaikosdk::StreamIndexServiceResponsePairs >*
      mutable_pairs();
  private:
  const ::kaikosdk::StreamIndexServiceResponsePairs& _internal_pairs(int index) const;
  ::kaikosdk::StreamIndexServiceResponsePairs* _internal_add_pairs();
  public:
  const ::kaikosdk::StreamIndexServiceResponsePairs& pairs(int index) const;
  ::kaikosdk::StreamIndexServiceResponsePairs* add_pairs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kaikosdk::StreamIndexServiceResponsePairs >&
      pairs() const;

  // double percentage = 1;
  void clear_percentage();
  double percentage() const;
  void set_percentage(double value);
  private:
  double _internal_percentage() const;
  void _internal_set_percentage(double value);
  public:

  // double price = 2;
  void clear_price();
  double price() const;
  void set_price(double value);
  private:
  double _internal_price() const;
  void _internal_set_price(double value);
  public:

  // @@protoc_insertion_point(class_scope:kaikosdk.StreamIndexServiceResponsePercentage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kaikosdk::StreamIndexServiceResponsePairs > pairs_;
    double percentage_;
    double price_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sdk_2fstream_2findex_5fv1_2fresponse_2eproto;
};
// -------------------------------------------------------------------

class StreamIndexServiceResponsePairs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kaikosdk.StreamIndexServiceResponsePairs) */ {
 public:
  inline StreamIndexServiceResponsePairs() : StreamIndexServiceResponsePairs(nullptr) {}
  ~StreamIndexServiceResponsePairs() override;
  explicit PROTOBUF_CONSTEXPR StreamIndexServiceResponsePairs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamIndexServiceResponsePairs(const StreamIndexServiceResponsePairs& from);
  StreamIndexServiceResponsePairs(StreamIndexServiceResponsePairs&& from) noexcept
    : StreamIndexServiceResponsePairs() {
    *this = ::std::move(from);
  }

  inline StreamIndexServiceResponsePairs& operator=(const StreamIndexServiceResponsePairs& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamIndexServiceResponsePairs& operator=(StreamIndexServiceResponsePairs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamIndexServiceResponsePairs& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamIndexServiceResponsePairs* internal_default_instance() {
    return reinterpret_cast<const StreamIndexServiceResponsePairs*>(
               &_StreamIndexServiceResponsePairs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(StreamIndexServiceResponsePairs& a, StreamIndexServiceResponsePairs& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamIndexServiceResponsePairs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamIndexServiceResponsePairs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamIndexServiceResponsePairs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamIndexServiceResponsePairs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamIndexServiceResponsePairs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamIndexServiceResponsePairs& from) {
    StreamIndexServiceResponsePairs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamIndexServiceResponsePairs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kaikosdk.StreamIndexServiceResponsePairs";
  }
  protected:
  explicit StreamIndexServiceResponsePairs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstrumentsFieldNumber = 3,
    kPairFieldNumber = 1,
    kWeightFieldNumber = 2,
  };
  // repeated .kaikosdk.StreamIndexServiceResponseInstruments instruments = 3;
  int instruments_size() const;
  private:
  int _internal_instruments_size() const;
  public:
  void clear_instruments();
  ::kaikosdk::StreamIndexServiceResponseInstruments* mutable_instruments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kaikosdk::StreamIndexServiceResponseInstruments >*
      mutable_instruments();
  private:
  const ::kaikosdk::StreamIndexServiceResponseInstruments& _internal_instruments(int index) const;
  ::kaikosdk::StreamIndexServiceResponseInstruments* _internal_add_instruments();
  public:
  const ::kaikosdk::StreamIndexServiceResponseInstruments& instruments(int index) const;
  ::kaikosdk::StreamIndexServiceResponseInstruments* add_instruments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kaikosdk::StreamIndexServiceResponseInstruments >&
      instruments() const;

  // string pair = 1;
  void clear_pair();
  const std::string& pair() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pair(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pair();
  PROTOBUF_NODISCARD std::string* release_pair();
  void set_allocated_pair(std::string* pair);
  private:
  const std::string& _internal_pair() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pair(const std::string& value);
  std::string* _internal_mutable_pair();
  public:

  // double weight = 2;
  void clear_weight();
  double weight() const;
  void set_weight(double value);
  private:
  double _internal_weight() const;
  void _internal_set_weight(double value);
  public:

  // @@protoc_insertion_point(class_scope:kaikosdk.StreamIndexServiceResponsePairs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kaikosdk::StreamIndexServiceResponseInstruments > instruments_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pair_;
    double weight_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sdk_2fstream_2findex_5fv1_2fresponse_2eproto;
};
// -------------------------------------------------------------------

class StreamIndexServiceUnderlyingTrade final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kaikosdk.StreamIndexServiceUnderlyingTrade) */ {
 public:
  inline StreamIndexServiceUnderlyingTrade() : StreamIndexServiceUnderlyingTrade(nullptr) {}
  ~StreamIndexServiceUnderlyingTrade() override;
  explicit PROTOBUF_CONSTEXPR StreamIndexServiceUnderlyingTrade(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamIndexServiceUnderlyingTrade(const StreamIndexServiceUnderlyingTrade& from);
  StreamIndexServiceUnderlyingTrade(StreamIndexServiceUnderlyingTrade&& from) noexcept
    : StreamIndexServiceUnderlyingTrade() {
    *this = ::std::move(from);
  }

  inline StreamIndexServiceUnderlyingTrade& operator=(const StreamIndexServiceUnderlyingTrade& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamIndexServiceUnderlyingTrade& operator=(StreamIndexServiceUnderlyingTrade&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamIndexServiceUnderlyingTrade& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamIndexServiceUnderlyingTrade* internal_default_instance() {
    return reinterpret_cast<const StreamIndexServiceUnderlyingTrade*>(
               &_StreamIndexServiceUnderlyingTrade_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(StreamIndexServiceUnderlyingTrade& a, StreamIndexServiceUnderlyingTrade& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamIndexServiceUnderlyingTrade* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamIndexServiceUnderlyingTrade* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamIndexServiceUnderlyingTrade* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamIndexServiceUnderlyingTrade>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamIndexServiceUnderlyingTrade& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamIndexServiceUnderlyingTrade& from) {
    StreamIndexServiceUnderlyingTrade::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamIndexServiceUnderlyingTrade* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kaikosdk.StreamIndexServiceUnderlyingTrade";
  }
  protected:
  explicit StreamIndexServiceUnderlyingTrade(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExchangeFieldNumber = 2,
    kIdFieldNumber = 3,
    kDatetimeFieldNumber = 4,
    kVolumeFieldNumber = 1,
  };
  // string exchange = 2;
  void clear_exchange();
  const std::string& exchange() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exchange(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exchange();
  PROTOBUF_NODISCARD std::string* release_exchange();
  void set_allocated_exchange(std::string* exchange);
  private:
  const std::string& _internal_exchange() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exchange(const std::string& value);
  std::string* _internal_mutable_exchange();
  public:

  // string id = 3;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .google.protobuf.Timestamp datetime = 4;
  bool has_datetime() const;
  private:
  bool _internal_has_datetime() const;
  public:
  void clear_datetime();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& datetime() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_datetime();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_datetime();
  void set_allocated_datetime(::PROTOBUF_NAMESPACE_ID::Timestamp* datetime);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_datetime() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_datetime();
  public:
  void unsafe_arena_set_allocated_datetime(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* datetime);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_datetime();

  // double volume = 1;
  void clear_volume();
  double volume() const;
  void set_volume(double value);
  private:
  double _internal_volume() const;
  void _internal_set_volume(double value);
  public:

  // @@protoc_insertion_point(class_scope:kaikosdk.StreamIndexServiceUnderlyingTrade)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exchange_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* datetime_;
    double volume_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sdk_2fstream_2findex_5fv1_2fresponse_2eproto;
};
// -------------------------------------------------------------------

class StreamIndexServiceResponseInstruments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kaikosdk.StreamIndexServiceResponseInstruments) */ {
 public:
  inline StreamIndexServiceResponseInstruments() : StreamIndexServiceResponseInstruments(nullptr) {}
  ~StreamIndexServiceResponseInstruments() override;
  explicit PROTOBUF_CONSTEXPR StreamIndexServiceResponseInstruments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamIndexServiceResponseInstruments(const StreamIndexServiceResponseInstruments& from);
  StreamIndexServiceResponseInstruments(StreamIndexServiceResponseInstruments&& from) noexcept
    : StreamIndexServiceResponseInstruments() {
    *this = ::std::move(from);
  }

  inline StreamIndexServiceResponseInstruments& operator=(const StreamIndexServiceResponseInstruments& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamIndexServiceResponseInstruments& operator=(StreamIndexServiceResponseInstruments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamIndexServiceResponseInstruments& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamIndexServiceResponseInstruments* internal_default_instance() {
    return reinterpret_cast<const StreamIndexServiceResponseInstruments*>(
               &_StreamIndexServiceResponseInstruments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(StreamIndexServiceResponseInstruments& a, StreamIndexServiceResponseInstruments& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamIndexServiceResponseInstruments* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamIndexServiceResponseInstruments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamIndexServiceResponseInstruments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamIndexServiceResponseInstruments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamIndexServiceResponseInstruments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamIndexServiceResponseInstruments& from) {
    StreamIndexServiceResponseInstruments::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamIndexServiceResponseInstruments* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kaikosdk.StreamIndexServiceResponseInstruments";
  }
  protected:
  explicit StreamIndexServiceResponseInstruments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartitionFieldNumber = 1,
    kUnderlyingTradeFieldNumber = 5,
    kPriceFieldNumber = 2,
    kVolumeFieldNumber = 3,
    kCountFieldNumber = 4,
  };
  // string partition = 1;
  void clear_partition();
  const std::string& partition() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_partition(ArgT0&& arg0, ArgT... args);
  std::string* mutable_partition();
  PROTOBUF_NODISCARD std::string* release_partition();
  void set_allocated_partition(std::string* partition);
  private:
  const std::string& _internal_partition() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_partition(const std::string& value);
  std::string* _internal_mutable_partition();
  public:

  // .kaikosdk.StreamIndexServiceUnderlyingTrade underlying_trade = 5;
  bool has_underlying_trade() const;
  private:
  bool _internal_has_underlying_trade() const;
  public:
  void clear_underlying_trade();
  const ::kaikosdk::StreamIndexServiceUnderlyingTrade& underlying_trade() const;
  PROTOBUF_NODISCARD ::kaikosdk::StreamIndexServiceUnderlyingTrade* release_underlying_trade();
  ::kaikosdk::StreamIndexServiceUnderlyingTrade* mutable_underlying_trade();
  void set_allocated_underlying_trade(::kaikosdk::StreamIndexServiceUnderlyingTrade* underlying_trade);
  private:
  const ::kaikosdk::StreamIndexServiceUnderlyingTrade& _internal_underlying_trade() const;
  ::kaikosdk::StreamIndexServiceUnderlyingTrade* _internal_mutable_underlying_trade();
  public:
  void unsafe_arena_set_allocated_underlying_trade(
      ::kaikosdk::StreamIndexServiceUnderlyingTrade* underlying_trade);
  ::kaikosdk::StreamIndexServiceUnderlyingTrade* unsafe_arena_release_underlying_trade();

  // double price = 2;
  void clear_price();
  double price() const;
  void set_price(double value);
  private:
  double _internal_price() const;
  void _internal_set_price(double value);
  public:

  // double volume = 3;
  void clear_volume();
  double volume() const;
  void set_volume(double value);
  private:
  double _internal_volume() const;
  void _internal_set_volume(double value);
  public:

  // uint64 count = 4;
  void clear_count();
  uint64_t count() const;
  void set_count(uint64_t value);
  private:
  uint64_t _internal_count() const;
  void _internal_set_count(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:kaikosdk.StreamIndexServiceResponseInstruments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr partition_;
    ::kaikosdk::StreamIndexServiceUnderlyingTrade* underlying_trade_;
    double price_;
    double volume_;
    uint64_t count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sdk_2fstream_2findex_5fv1_2fresponse_2eproto;
};
// -------------------------------------------------------------------

class StreamIndexServiceResponseBaseAsset final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kaikosdk.StreamIndexServiceResponseBaseAsset) */ {
 public:
  inline StreamIndexServiceResponseBaseAsset() : StreamIndexServiceResponseBaseAsset(nullptr) {}
  ~StreamIndexServiceResponseBaseAsset() override;
  explicit PROTOBUF_CONSTEXPR StreamIndexServiceResponseBaseAsset(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamIndexServiceResponseBaseAsset(const StreamIndexServiceResponseBaseAsset& from);
  StreamIndexServiceResponseBaseAsset(StreamIndexServiceResponseBaseAsset&& from) noexcept
    : StreamIndexServiceResponseBaseAsset() {
    *this = ::std::move(from);
  }

  inline StreamIndexServiceResponseBaseAsset& operator=(const StreamIndexServiceResponseBaseAsset& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamIndexServiceResponseBaseAsset& operator=(StreamIndexServiceResponseBaseAsset&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamIndexServiceResponseBaseAsset& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamIndexServiceResponseBaseAsset* internal_default_instance() {
    return reinterpret_cast<const StreamIndexServiceResponseBaseAsset*>(
               &_StreamIndexServiceResponseBaseAsset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(StreamIndexServiceResponseBaseAsset& a, StreamIndexServiceResponseBaseAsset& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamIndexServiceResponseBaseAsset* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamIndexServiceResponseBaseAsset* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamIndexServiceResponseBaseAsset* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamIndexServiceResponseBaseAsset>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamIndexServiceResponseBaseAsset& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamIndexServiceResponseBaseAsset& from) {
    StreamIndexServiceResponseBaseAsset::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamIndexServiceResponseBaseAsset* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kaikosdk.StreamIndexServiceResponseBaseAsset";
  }
  protected:
  explicit StreamIndexServiceResponseBaseAsset(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssetFieldNumber = 1,
    kWeightFieldNumber = 2,
  };
  // string asset = 1;
  void clear_asset();
  const std::string& asset() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_asset(ArgT0&& arg0, ArgT... args);
  std::string* mutable_asset();
  PROTOBUF_NODISCARD std::string* release_asset();
  void set_allocated_asset(std::string* asset);
  private:
  const std::string& _internal_asset() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_asset(const std::string& value);
  std::string* _internal_mutable_asset();
  public:

  // double weight = 2;
  void clear_weight();
  double weight() const;
  void set_weight(double value);
  private:
  double _internal_weight() const;
  void _internal_set_weight(double value);
  public:

  // @@protoc_insertion_point(class_scope:kaikosdk.StreamIndexServiceResponseBaseAsset)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr asset_;
    double weight_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sdk_2fstream_2findex_5fv1_2fresponse_2eproto;
};
// -------------------------------------------------------------------

class StreamIndexServiceResponseV1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:kaikosdk.StreamIndexServiceResponseV1) */ {
 public:
  inline StreamIndexServiceResponseV1() : StreamIndexServiceResponseV1(nullptr) {}
  ~StreamIndexServiceResponseV1() override;
  explicit PROTOBUF_CONSTEXPR StreamIndexServiceResponseV1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamIndexServiceResponseV1(const StreamIndexServiceResponseV1& from);
  StreamIndexServiceResponseV1(StreamIndexServiceResponseV1&& from) noexcept
    : StreamIndexServiceResponseV1() {
    *this = ::std::move(from);
  }

  inline StreamIndexServiceResponseV1& operator=(const StreamIndexServiceResponseV1& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamIndexServiceResponseV1& operator=(StreamIndexServiceResponseV1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamIndexServiceResponseV1& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamIndexServiceResponseV1* internal_default_instance() {
    return reinterpret_cast<const StreamIndexServiceResponseV1*>(
               &_StreamIndexServiceResponseV1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(StreamIndexServiceResponseV1& a, StreamIndexServiceResponseV1& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamIndexServiceResponseV1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamIndexServiceResponseV1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamIndexServiceResponseV1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamIndexServiceResponseV1>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamIndexServiceResponseV1& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamIndexServiceResponseV1& from) {
    StreamIndexServiceResponseV1::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamIndexServiceResponseV1* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kaikosdk.StreamIndexServiceResponseV1";
  }
  protected:
  explicit StreamIndexServiceResponseV1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBasesFieldNumber = 5,
    kExchangesFieldNumber = 6,
    kPercentagesFieldNumber = 7,
    kIndexCodeFieldNumber = 1,
    kQuoteFieldNumber = 4,
    kSequenceIdFieldNumber = 9,
    kIntervalFieldNumber = 3,
    kTsEventFieldNumber = 8,
    kLastIngestTimeFieldNumber = 10,
    kCommodityFieldNumber = 2,
  };
  // repeated .kaikosdk.StreamIndexServiceResponseBaseAsset bases = 5;
  int bases_size() const;
  private:
  int _internal_bases_size() const;
  public:
  void clear_bases();
  ::kaikosdk::StreamIndexServiceResponseBaseAsset* mutable_bases(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kaikosdk::StreamIndexServiceResponseBaseAsset >*
      mutable_bases();
  private:
  const ::kaikosdk::StreamIndexServiceResponseBaseAsset& _internal_bases(int index) const;
  ::kaikosdk::StreamIndexServiceResponseBaseAsset* _internal_add_bases();
  public:
  const ::kaikosdk::StreamIndexServiceResponseBaseAsset& bases(int index) const;
  ::kaikosdk::StreamIndexServiceResponseBaseAsset* add_bases();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kaikosdk::StreamIndexServiceResponseBaseAsset >&
      bases() const;

  // repeated string exchanges = 6;
  int exchanges_size() const;
  private:
  int _internal_exchanges_size() const;
  public:
  void clear_exchanges();
  const std::string& exchanges(int index) const;
  std::string* mutable_exchanges(int index);
  void set_exchanges(int index, const std::string& value);
  void set_exchanges(int index, std::string&& value);
  void set_exchanges(int index, const char* value);
  void set_exchanges(int index, const char* value, size_t size);
  std::string* add_exchanges();
  void add_exchanges(const std::string& value);
  void add_exchanges(std::string&& value);
  void add_exchanges(const char* value);
  void add_exchanges(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& exchanges() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_exchanges();
  private:
  const std::string& _internal_exchanges(int index) const;
  std::string* _internal_add_exchanges();
  public:

  // repeated .kaikosdk.StreamIndexServiceResponsePercentage percentages = 7;
  int percentages_size() const;
  private:
  int _internal_percentages_size() const;
  public:
  void clear_percentages();
  ::kaikosdk::StreamIndexServiceResponsePercentage* mutable_percentages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kaikosdk::StreamIndexServiceResponsePercentage >*
      mutable_percentages();
  private:
  const ::kaikosdk::StreamIndexServiceResponsePercentage& _internal_percentages(int index) const;
  ::kaikosdk::StreamIndexServiceResponsePercentage* _internal_add_percentages();
  public:
  const ::kaikosdk::StreamIndexServiceResponsePercentage& percentages(int index) const;
  ::kaikosdk::StreamIndexServiceResponsePercentage* add_percentages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kaikosdk::StreamIndexServiceResponsePercentage >&
      percentages() const;

  // string index_code = 1;
  void clear_index_code();
  const std::string& index_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_index_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_index_code();
  PROTOBUF_NODISCARD std::string* release_index_code();
  void set_allocated_index_code(std::string* index_code);
  private:
  const std::string& _internal_index_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_index_code(const std::string& value);
  std::string* _internal_mutable_index_code();
  public:

  // string quote = 4;
  void clear_quote();
  const std::string& quote() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_quote(ArgT0&& arg0, ArgT... args);
  std::string* mutable_quote();
  PROTOBUF_NODISCARD std::string* release_quote();
  void set_allocated_quote(std::string* quote);
  private:
  const std::string& _internal_quote() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quote(const std::string& value);
  std::string* _internal_mutable_quote();
  public:

  // string sequence_id = 9;
  void clear_sequence_id();
  const std::string& sequence_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sequence_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sequence_id();
  PROTOBUF_NODISCARD std::string* release_sequence_id();
  void set_allocated_sequence_id(std::string* sequence_id);
  private:
  const std::string& _internal_sequence_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sequence_id(const std::string& value);
  std::string* _internal_mutable_sequence_id();
  public:

  // .kaikosdk.DataInterval interval = 3;
  bool has_interval() const;
  private:
  bool _internal_has_interval() const;
  public:
  void clear_interval();
  const ::kaikosdk::DataInterval& interval() const;
  PROTOBUF_NODISCARD ::kaikosdk::DataInterval* release_interval();
  ::kaikosdk::DataInterval* mutable_interval();
  void set_allocated_interval(::kaikosdk::DataInterval* interval);
  private:
  const ::kaikosdk::DataInterval& _internal_interval() const;
  ::kaikosdk::DataInterval* _internal_mutable_interval();
  public:
  void unsafe_arena_set_allocated_interval(
      ::kaikosdk::DataInterval* interval);
  ::kaikosdk::DataInterval* unsafe_arena_release_interval();

  // .google.protobuf.Timestamp ts_event = 8;
  bool has_ts_event() const;
  private:
  bool _internal_has_ts_event() const;
  public:
  void clear_ts_event();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& ts_event() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_ts_event();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_ts_event();
  void set_allocated_ts_event(::PROTOBUF_NAMESPACE_ID::Timestamp* ts_event);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_ts_event() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_ts_event();
  public:
  void unsafe_arena_set_allocated_ts_event(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* ts_event);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_ts_event();

  // .google.protobuf.Timestamp last_ingest_time = 10;
  bool has_last_ingest_time() const;
  private:
  bool _internal_has_last_ingest_time() const;
  public:
  void clear_last_ingest_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_ingest_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_ingest_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_ingest_time();
  void set_allocated_last_ingest_time(::PROTOBUF_NAMESPACE_ID::Timestamp* last_ingest_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_ingest_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_ingest_time();
  public:
  void unsafe_arena_set_allocated_last_ingest_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_ingest_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_ingest_time();

  // .kaikosdk.StreamIndexCommodity commodity = 2;
  void clear_commodity();
  ::kaikosdk::StreamIndexCommodity commodity() const;
  void set_commodity(::kaikosdk::StreamIndexCommodity value);
  private:
  ::kaikosdk::StreamIndexCommodity _internal_commodity() const;
  void _internal_set_commodity(::kaikosdk::StreamIndexCommodity value);
  public:

  // @@protoc_insertion_point(class_scope:kaikosdk.StreamIndexServiceResponseV1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kaikosdk::StreamIndexServiceResponseBaseAsset > bases_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> exchanges_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kaikosdk::StreamIndexServiceResponsePercentage > percentages_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr index_code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quote_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sequence_id_;
    ::kaikosdk::DataInterval* interval_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* ts_event_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_ingest_time_;
    int commodity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sdk_2fstream_2findex_5fv1_2fresponse_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// StreamIndexServiceResponsePercentage

// double percentage = 1;
inline void StreamIndexServiceResponsePercentage::clear_percentage() {
  _impl_.percentage_ = 0;
}
inline double StreamIndexServiceResponsePercentage::_internal_percentage() const {
  return _impl_.percentage_;
}
inline double StreamIndexServiceResponsePercentage::percentage() const {
  // @@protoc_insertion_point(field_get:kaikosdk.StreamIndexServiceResponsePercentage.percentage)
  return _internal_percentage();
}
inline void StreamIndexServiceResponsePercentage::_internal_set_percentage(double value) {
  
  _impl_.percentage_ = value;
}
inline void StreamIndexServiceResponsePercentage::set_percentage(double value) {
  _internal_set_percentage(value);
  // @@protoc_insertion_point(field_set:kaikosdk.StreamIndexServiceResponsePercentage.percentage)
}

// double price = 2;
inline void StreamIndexServiceResponsePercentage::clear_price() {
  _impl_.price_ = 0;
}
inline double StreamIndexServiceResponsePercentage::_internal_price() const {
  return _impl_.price_;
}
inline double StreamIndexServiceResponsePercentage::price() const {
  // @@protoc_insertion_point(field_get:kaikosdk.StreamIndexServiceResponsePercentage.price)
  return _internal_price();
}
inline void StreamIndexServiceResponsePercentage::_internal_set_price(double value) {
  
  _impl_.price_ = value;
}
inline void StreamIndexServiceResponsePercentage::set_price(double value) {
  _internal_set_price(value);
  // @@protoc_insertion_point(field_set:kaikosdk.StreamIndexServiceResponsePercentage.price)
}

// repeated .kaikosdk.StreamIndexServiceResponsePairs pairs = 3;
inline int StreamIndexServiceResponsePercentage::_internal_pairs_size() const {
  return _impl_.pairs_.size();
}
inline int StreamIndexServiceResponsePercentage::pairs_size() const {
  return _internal_pairs_size();
}
inline void StreamIndexServiceResponsePercentage::clear_pairs() {
  _impl_.pairs_.Clear();
}
inline ::kaikosdk::StreamIndexServiceResponsePairs* StreamIndexServiceResponsePercentage::mutable_pairs(int index) {
  // @@protoc_insertion_point(field_mutable:kaikosdk.StreamIndexServiceResponsePercentage.pairs)
  return _impl_.pairs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kaikosdk::StreamIndexServiceResponsePairs >*
StreamIndexServiceResponsePercentage::mutable_pairs() {
  // @@protoc_insertion_point(field_mutable_list:kaikosdk.StreamIndexServiceResponsePercentage.pairs)
  return &_impl_.pairs_;
}
inline const ::kaikosdk::StreamIndexServiceResponsePairs& StreamIndexServiceResponsePercentage::_internal_pairs(int index) const {
  return _impl_.pairs_.Get(index);
}
inline const ::kaikosdk::StreamIndexServiceResponsePairs& StreamIndexServiceResponsePercentage::pairs(int index) const {
  // @@protoc_insertion_point(field_get:kaikosdk.StreamIndexServiceResponsePercentage.pairs)
  return _internal_pairs(index);
}
inline ::kaikosdk::StreamIndexServiceResponsePairs* StreamIndexServiceResponsePercentage::_internal_add_pairs() {
  return _impl_.pairs_.Add();
}
inline ::kaikosdk::StreamIndexServiceResponsePairs* StreamIndexServiceResponsePercentage::add_pairs() {
  ::kaikosdk::StreamIndexServiceResponsePairs* _add = _internal_add_pairs();
  // @@protoc_insertion_point(field_add:kaikosdk.StreamIndexServiceResponsePercentage.pairs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kaikosdk::StreamIndexServiceResponsePairs >&
StreamIndexServiceResponsePercentage::pairs() const {
  // @@protoc_insertion_point(field_list:kaikosdk.StreamIndexServiceResponsePercentage.pairs)
  return _impl_.pairs_;
}

// -------------------------------------------------------------------

// StreamIndexServiceResponsePairs

// string pair = 1;
inline void StreamIndexServiceResponsePairs::clear_pair() {
  _impl_.pair_.ClearToEmpty();
}
inline const std::string& StreamIndexServiceResponsePairs::pair() const {
  // @@protoc_insertion_point(field_get:kaikosdk.StreamIndexServiceResponsePairs.pair)
  return _internal_pair();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamIndexServiceResponsePairs::set_pair(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pair_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kaikosdk.StreamIndexServiceResponsePairs.pair)
}
inline std::string* StreamIndexServiceResponsePairs::mutable_pair() {
  std::string* _s = _internal_mutable_pair();
  // @@protoc_insertion_point(field_mutable:kaikosdk.StreamIndexServiceResponsePairs.pair)
  return _s;
}
inline const std::string& StreamIndexServiceResponsePairs::_internal_pair() const {
  return _impl_.pair_.Get();
}
inline void StreamIndexServiceResponsePairs::_internal_set_pair(const std::string& value) {
  
  _impl_.pair_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamIndexServiceResponsePairs::_internal_mutable_pair() {
  
  return _impl_.pair_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamIndexServiceResponsePairs::release_pair() {
  // @@protoc_insertion_point(field_release:kaikosdk.StreamIndexServiceResponsePairs.pair)
  return _impl_.pair_.Release();
}
inline void StreamIndexServiceResponsePairs::set_allocated_pair(std::string* pair) {
  if (pair != nullptr) {
    
  } else {
    
  }
  _impl_.pair_.SetAllocated(pair, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pair_.IsDefault()) {
    _impl_.pair_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kaikosdk.StreamIndexServiceResponsePairs.pair)
}

// double weight = 2;
inline void StreamIndexServiceResponsePairs::clear_weight() {
  _impl_.weight_ = 0;
}
inline double StreamIndexServiceResponsePairs::_internal_weight() const {
  return _impl_.weight_;
}
inline double StreamIndexServiceResponsePairs::weight() const {
  // @@protoc_insertion_point(field_get:kaikosdk.StreamIndexServiceResponsePairs.weight)
  return _internal_weight();
}
inline void StreamIndexServiceResponsePairs::_internal_set_weight(double value) {
  
  _impl_.weight_ = value;
}
inline void StreamIndexServiceResponsePairs::set_weight(double value) {
  _internal_set_weight(value);
  // @@protoc_insertion_point(field_set:kaikosdk.StreamIndexServiceResponsePairs.weight)
}

// repeated .kaikosdk.StreamIndexServiceResponseInstruments instruments = 3;
inline int StreamIndexServiceResponsePairs::_internal_instruments_size() const {
  return _impl_.instruments_.size();
}
inline int StreamIndexServiceResponsePairs::instruments_size() const {
  return _internal_instruments_size();
}
inline void StreamIndexServiceResponsePairs::clear_instruments() {
  _impl_.instruments_.Clear();
}
inline ::kaikosdk::StreamIndexServiceResponseInstruments* StreamIndexServiceResponsePairs::mutable_instruments(int index) {
  // @@protoc_insertion_point(field_mutable:kaikosdk.StreamIndexServiceResponsePairs.instruments)
  return _impl_.instruments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kaikosdk::StreamIndexServiceResponseInstruments >*
StreamIndexServiceResponsePairs::mutable_instruments() {
  // @@protoc_insertion_point(field_mutable_list:kaikosdk.StreamIndexServiceResponsePairs.instruments)
  return &_impl_.instruments_;
}
inline const ::kaikosdk::StreamIndexServiceResponseInstruments& StreamIndexServiceResponsePairs::_internal_instruments(int index) const {
  return _impl_.instruments_.Get(index);
}
inline const ::kaikosdk::StreamIndexServiceResponseInstruments& StreamIndexServiceResponsePairs::instruments(int index) const {
  // @@protoc_insertion_point(field_get:kaikosdk.StreamIndexServiceResponsePairs.instruments)
  return _internal_instruments(index);
}
inline ::kaikosdk::StreamIndexServiceResponseInstruments* StreamIndexServiceResponsePairs::_internal_add_instruments() {
  return _impl_.instruments_.Add();
}
inline ::kaikosdk::StreamIndexServiceResponseInstruments* StreamIndexServiceResponsePairs::add_instruments() {
  ::kaikosdk::StreamIndexServiceResponseInstruments* _add = _internal_add_instruments();
  // @@protoc_insertion_point(field_add:kaikosdk.StreamIndexServiceResponsePairs.instruments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kaikosdk::StreamIndexServiceResponseInstruments >&
StreamIndexServiceResponsePairs::instruments() const {
  // @@protoc_insertion_point(field_list:kaikosdk.StreamIndexServiceResponsePairs.instruments)
  return _impl_.instruments_;
}

// -------------------------------------------------------------------

// StreamIndexServiceUnderlyingTrade

// double volume = 1;
inline void StreamIndexServiceUnderlyingTrade::clear_volume() {
  _impl_.volume_ = 0;
}
inline double StreamIndexServiceUnderlyingTrade::_internal_volume() const {
  return _impl_.volume_;
}
inline double StreamIndexServiceUnderlyingTrade::volume() const {
  // @@protoc_insertion_point(field_get:kaikosdk.StreamIndexServiceUnderlyingTrade.volume)
  return _internal_volume();
}
inline void StreamIndexServiceUnderlyingTrade::_internal_set_volume(double value) {
  
  _impl_.volume_ = value;
}
inline void StreamIndexServiceUnderlyingTrade::set_volume(double value) {
  _internal_set_volume(value);
  // @@protoc_insertion_point(field_set:kaikosdk.StreamIndexServiceUnderlyingTrade.volume)
}

// string exchange = 2;
inline void StreamIndexServiceUnderlyingTrade::clear_exchange() {
  _impl_.exchange_.ClearToEmpty();
}
inline const std::string& StreamIndexServiceUnderlyingTrade::exchange() const {
  // @@protoc_insertion_point(field_get:kaikosdk.StreamIndexServiceUnderlyingTrade.exchange)
  return _internal_exchange();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamIndexServiceUnderlyingTrade::set_exchange(ArgT0&& arg0, ArgT... args) {
 
 _impl_.exchange_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kaikosdk.StreamIndexServiceUnderlyingTrade.exchange)
}
inline std::string* StreamIndexServiceUnderlyingTrade::mutable_exchange() {
  std::string* _s = _internal_mutable_exchange();
  // @@protoc_insertion_point(field_mutable:kaikosdk.StreamIndexServiceUnderlyingTrade.exchange)
  return _s;
}
inline const std::string& StreamIndexServiceUnderlyingTrade::_internal_exchange() const {
  return _impl_.exchange_.Get();
}
inline void StreamIndexServiceUnderlyingTrade::_internal_set_exchange(const std::string& value) {
  
  _impl_.exchange_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamIndexServiceUnderlyingTrade::_internal_mutable_exchange() {
  
  return _impl_.exchange_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamIndexServiceUnderlyingTrade::release_exchange() {
  // @@protoc_insertion_point(field_release:kaikosdk.StreamIndexServiceUnderlyingTrade.exchange)
  return _impl_.exchange_.Release();
}
inline void StreamIndexServiceUnderlyingTrade::set_allocated_exchange(std::string* exchange) {
  if (exchange != nullptr) {
    
  } else {
    
  }
  _impl_.exchange_.SetAllocated(exchange, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.exchange_.IsDefault()) {
    _impl_.exchange_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kaikosdk.StreamIndexServiceUnderlyingTrade.exchange)
}

// string id = 3;
inline void StreamIndexServiceUnderlyingTrade::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& StreamIndexServiceUnderlyingTrade::id() const {
  // @@protoc_insertion_point(field_get:kaikosdk.StreamIndexServiceUnderlyingTrade.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamIndexServiceUnderlyingTrade::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kaikosdk.StreamIndexServiceUnderlyingTrade.id)
}
inline std::string* StreamIndexServiceUnderlyingTrade::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:kaikosdk.StreamIndexServiceUnderlyingTrade.id)
  return _s;
}
inline const std::string& StreamIndexServiceUnderlyingTrade::_internal_id() const {
  return _impl_.id_.Get();
}
inline void StreamIndexServiceUnderlyingTrade::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamIndexServiceUnderlyingTrade::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamIndexServiceUnderlyingTrade::release_id() {
  // @@protoc_insertion_point(field_release:kaikosdk.StreamIndexServiceUnderlyingTrade.id)
  return _impl_.id_.Release();
}
inline void StreamIndexServiceUnderlyingTrade::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kaikosdk.StreamIndexServiceUnderlyingTrade.id)
}

// .google.protobuf.Timestamp datetime = 4;
inline bool StreamIndexServiceUnderlyingTrade::_internal_has_datetime() const {
  return this != internal_default_instance() && _impl_.datetime_ != nullptr;
}
inline bool StreamIndexServiceUnderlyingTrade::has_datetime() const {
  return _internal_has_datetime();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& StreamIndexServiceUnderlyingTrade::_internal_datetime() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.datetime_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& StreamIndexServiceUnderlyingTrade::datetime() const {
  // @@protoc_insertion_point(field_get:kaikosdk.StreamIndexServiceUnderlyingTrade.datetime)
  return _internal_datetime();
}
inline void StreamIndexServiceUnderlyingTrade::unsafe_arena_set_allocated_datetime(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* datetime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.datetime_);
  }
  _impl_.datetime_ = datetime;
  if (datetime) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kaikosdk.StreamIndexServiceUnderlyingTrade.datetime)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* StreamIndexServiceUnderlyingTrade::release_datetime() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.datetime_;
  _impl_.datetime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* StreamIndexServiceUnderlyingTrade::unsafe_arena_release_datetime() {
  // @@protoc_insertion_point(field_release:kaikosdk.StreamIndexServiceUnderlyingTrade.datetime)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.datetime_;
  _impl_.datetime_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* StreamIndexServiceUnderlyingTrade::_internal_mutable_datetime() {
  
  if (_impl_.datetime_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.datetime_ = p;
  }
  return _impl_.datetime_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* StreamIndexServiceUnderlyingTrade::mutable_datetime() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_datetime();
  // @@protoc_insertion_point(field_mutable:kaikosdk.StreamIndexServiceUnderlyingTrade.datetime)
  return _msg;
}
inline void StreamIndexServiceUnderlyingTrade::set_allocated_datetime(::PROTOBUF_NAMESPACE_ID::Timestamp* datetime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.datetime_);
  }
  if (datetime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(datetime));
    if (message_arena != submessage_arena) {
      datetime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, datetime, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.datetime_ = datetime;
  // @@protoc_insertion_point(field_set_allocated:kaikosdk.StreamIndexServiceUnderlyingTrade.datetime)
}

// -------------------------------------------------------------------

// StreamIndexServiceResponseInstruments

// string partition = 1;
inline void StreamIndexServiceResponseInstruments::clear_partition() {
  _impl_.partition_.ClearToEmpty();
}
inline const std::string& StreamIndexServiceResponseInstruments::partition() const {
  // @@protoc_insertion_point(field_get:kaikosdk.StreamIndexServiceResponseInstruments.partition)
  return _internal_partition();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamIndexServiceResponseInstruments::set_partition(ArgT0&& arg0, ArgT... args) {
 
 _impl_.partition_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kaikosdk.StreamIndexServiceResponseInstruments.partition)
}
inline std::string* StreamIndexServiceResponseInstruments::mutable_partition() {
  std::string* _s = _internal_mutable_partition();
  // @@protoc_insertion_point(field_mutable:kaikosdk.StreamIndexServiceResponseInstruments.partition)
  return _s;
}
inline const std::string& StreamIndexServiceResponseInstruments::_internal_partition() const {
  return _impl_.partition_.Get();
}
inline void StreamIndexServiceResponseInstruments::_internal_set_partition(const std::string& value) {
  
  _impl_.partition_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamIndexServiceResponseInstruments::_internal_mutable_partition() {
  
  return _impl_.partition_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamIndexServiceResponseInstruments::release_partition() {
  // @@protoc_insertion_point(field_release:kaikosdk.StreamIndexServiceResponseInstruments.partition)
  return _impl_.partition_.Release();
}
inline void StreamIndexServiceResponseInstruments::set_allocated_partition(std::string* partition) {
  if (partition != nullptr) {
    
  } else {
    
  }
  _impl_.partition_.SetAllocated(partition, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.partition_.IsDefault()) {
    _impl_.partition_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kaikosdk.StreamIndexServiceResponseInstruments.partition)
}

// double price = 2;
inline void StreamIndexServiceResponseInstruments::clear_price() {
  _impl_.price_ = 0;
}
inline double StreamIndexServiceResponseInstruments::_internal_price() const {
  return _impl_.price_;
}
inline double StreamIndexServiceResponseInstruments::price() const {
  // @@protoc_insertion_point(field_get:kaikosdk.StreamIndexServiceResponseInstruments.price)
  return _internal_price();
}
inline void StreamIndexServiceResponseInstruments::_internal_set_price(double value) {
  
  _impl_.price_ = value;
}
inline void StreamIndexServiceResponseInstruments::set_price(double value) {
  _internal_set_price(value);
  // @@protoc_insertion_point(field_set:kaikosdk.StreamIndexServiceResponseInstruments.price)
}

// double volume = 3;
inline void StreamIndexServiceResponseInstruments::clear_volume() {
  _impl_.volume_ = 0;
}
inline double StreamIndexServiceResponseInstruments::_internal_volume() const {
  return _impl_.volume_;
}
inline double StreamIndexServiceResponseInstruments::volume() const {
  // @@protoc_insertion_point(field_get:kaikosdk.StreamIndexServiceResponseInstruments.volume)
  return _internal_volume();
}
inline void StreamIndexServiceResponseInstruments::_internal_set_volume(double value) {
  
  _impl_.volume_ = value;
}
inline void StreamIndexServiceResponseInstruments::set_volume(double value) {
  _internal_set_volume(value);
  // @@protoc_insertion_point(field_set:kaikosdk.StreamIndexServiceResponseInstruments.volume)
}

// uint64 count = 4;
inline void StreamIndexServiceResponseInstruments::clear_count() {
  _impl_.count_ = uint64_t{0u};
}
inline uint64_t StreamIndexServiceResponseInstruments::_internal_count() const {
  return _impl_.count_;
}
inline uint64_t StreamIndexServiceResponseInstruments::count() const {
  // @@protoc_insertion_point(field_get:kaikosdk.StreamIndexServiceResponseInstruments.count)
  return _internal_count();
}
inline void StreamIndexServiceResponseInstruments::_internal_set_count(uint64_t value) {
  
  _impl_.count_ = value;
}
inline void StreamIndexServiceResponseInstruments::set_count(uint64_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:kaikosdk.StreamIndexServiceResponseInstruments.count)
}

// .kaikosdk.StreamIndexServiceUnderlyingTrade underlying_trade = 5;
inline bool StreamIndexServiceResponseInstruments::_internal_has_underlying_trade() const {
  return this != internal_default_instance() && _impl_.underlying_trade_ != nullptr;
}
inline bool StreamIndexServiceResponseInstruments::has_underlying_trade() const {
  return _internal_has_underlying_trade();
}
inline void StreamIndexServiceResponseInstruments::clear_underlying_trade() {
  if (GetArenaForAllocation() == nullptr && _impl_.underlying_trade_ != nullptr) {
    delete _impl_.underlying_trade_;
  }
  _impl_.underlying_trade_ = nullptr;
}
inline const ::kaikosdk::StreamIndexServiceUnderlyingTrade& StreamIndexServiceResponseInstruments::_internal_underlying_trade() const {
  const ::kaikosdk::StreamIndexServiceUnderlyingTrade* p = _impl_.underlying_trade_;
  return p != nullptr ? *p : reinterpret_cast<const ::kaikosdk::StreamIndexServiceUnderlyingTrade&>(
      ::kaikosdk::_StreamIndexServiceUnderlyingTrade_default_instance_);
}
inline const ::kaikosdk::StreamIndexServiceUnderlyingTrade& StreamIndexServiceResponseInstruments::underlying_trade() const {
  // @@protoc_insertion_point(field_get:kaikosdk.StreamIndexServiceResponseInstruments.underlying_trade)
  return _internal_underlying_trade();
}
inline void StreamIndexServiceResponseInstruments::unsafe_arena_set_allocated_underlying_trade(
    ::kaikosdk::StreamIndexServiceUnderlyingTrade* underlying_trade) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.underlying_trade_);
  }
  _impl_.underlying_trade_ = underlying_trade;
  if (underlying_trade) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kaikosdk.StreamIndexServiceResponseInstruments.underlying_trade)
}
inline ::kaikosdk::StreamIndexServiceUnderlyingTrade* StreamIndexServiceResponseInstruments::release_underlying_trade() {
  
  ::kaikosdk::StreamIndexServiceUnderlyingTrade* temp = _impl_.underlying_trade_;
  _impl_.underlying_trade_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kaikosdk::StreamIndexServiceUnderlyingTrade* StreamIndexServiceResponseInstruments::unsafe_arena_release_underlying_trade() {
  // @@protoc_insertion_point(field_release:kaikosdk.StreamIndexServiceResponseInstruments.underlying_trade)
  
  ::kaikosdk::StreamIndexServiceUnderlyingTrade* temp = _impl_.underlying_trade_;
  _impl_.underlying_trade_ = nullptr;
  return temp;
}
inline ::kaikosdk::StreamIndexServiceUnderlyingTrade* StreamIndexServiceResponseInstruments::_internal_mutable_underlying_trade() {
  
  if (_impl_.underlying_trade_ == nullptr) {
    auto* p = CreateMaybeMessage<::kaikosdk::StreamIndexServiceUnderlyingTrade>(GetArenaForAllocation());
    _impl_.underlying_trade_ = p;
  }
  return _impl_.underlying_trade_;
}
inline ::kaikosdk::StreamIndexServiceUnderlyingTrade* StreamIndexServiceResponseInstruments::mutable_underlying_trade() {
  ::kaikosdk::StreamIndexServiceUnderlyingTrade* _msg = _internal_mutable_underlying_trade();
  // @@protoc_insertion_point(field_mutable:kaikosdk.StreamIndexServiceResponseInstruments.underlying_trade)
  return _msg;
}
inline void StreamIndexServiceResponseInstruments::set_allocated_underlying_trade(::kaikosdk::StreamIndexServiceUnderlyingTrade* underlying_trade) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.underlying_trade_;
  }
  if (underlying_trade) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(underlying_trade);
    if (message_arena != submessage_arena) {
      underlying_trade = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, underlying_trade, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.underlying_trade_ = underlying_trade;
  // @@protoc_insertion_point(field_set_allocated:kaikosdk.StreamIndexServiceResponseInstruments.underlying_trade)
}

// -------------------------------------------------------------------

// StreamIndexServiceResponseBaseAsset

// string asset = 1;
inline void StreamIndexServiceResponseBaseAsset::clear_asset() {
  _impl_.asset_.ClearToEmpty();
}
inline const std::string& StreamIndexServiceResponseBaseAsset::asset() const {
  // @@protoc_insertion_point(field_get:kaikosdk.StreamIndexServiceResponseBaseAsset.asset)
  return _internal_asset();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamIndexServiceResponseBaseAsset::set_asset(ArgT0&& arg0, ArgT... args) {
 
 _impl_.asset_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kaikosdk.StreamIndexServiceResponseBaseAsset.asset)
}
inline std::string* StreamIndexServiceResponseBaseAsset::mutable_asset() {
  std::string* _s = _internal_mutable_asset();
  // @@protoc_insertion_point(field_mutable:kaikosdk.StreamIndexServiceResponseBaseAsset.asset)
  return _s;
}
inline const std::string& StreamIndexServiceResponseBaseAsset::_internal_asset() const {
  return _impl_.asset_.Get();
}
inline void StreamIndexServiceResponseBaseAsset::_internal_set_asset(const std::string& value) {
  
  _impl_.asset_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamIndexServiceResponseBaseAsset::_internal_mutable_asset() {
  
  return _impl_.asset_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamIndexServiceResponseBaseAsset::release_asset() {
  // @@protoc_insertion_point(field_release:kaikosdk.StreamIndexServiceResponseBaseAsset.asset)
  return _impl_.asset_.Release();
}
inline void StreamIndexServiceResponseBaseAsset::set_allocated_asset(std::string* asset) {
  if (asset != nullptr) {
    
  } else {
    
  }
  _impl_.asset_.SetAllocated(asset, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.asset_.IsDefault()) {
    _impl_.asset_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kaikosdk.StreamIndexServiceResponseBaseAsset.asset)
}

// double weight = 2;
inline void StreamIndexServiceResponseBaseAsset::clear_weight() {
  _impl_.weight_ = 0;
}
inline double StreamIndexServiceResponseBaseAsset::_internal_weight() const {
  return _impl_.weight_;
}
inline double StreamIndexServiceResponseBaseAsset::weight() const {
  // @@protoc_insertion_point(field_get:kaikosdk.StreamIndexServiceResponseBaseAsset.weight)
  return _internal_weight();
}
inline void StreamIndexServiceResponseBaseAsset::_internal_set_weight(double value) {
  
  _impl_.weight_ = value;
}
inline void StreamIndexServiceResponseBaseAsset::set_weight(double value) {
  _internal_set_weight(value);
  // @@protoc_insertion_point(field_set:kaikosdk.StreamIndexServiceResponseBaseAsset.weight)
}

// -------------------------------------------------------------------

// StreamIndexServiceResponseV1

// string index_code = 1;
inline void StreamIndexServiceResponseV1::clear_index_code() {
  _impl_.index_code_.ClearToEmpty();
}
inline const std::string& StreamIndexServiceResponseV1::index_code() const {
  // @@protoc_insertion_point(field_get:kaikosdk.StreamIndexServiceResponseV1.index_code)
  return _internal_index_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamIndexServiceResponseV1::set_index_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.index_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kaikosdk.StreamIndexServiceResponseV1.index_code)
}
inline std::string* StreamIndexServiceResponseV1::mutable_index_code() {
  std::string* _s = _internal_mutable_index_code();
  // @@protoc_insertion_point(field_mutable:kaikosdk.StreamIndexServiceResponseV1.index_code)
  return _s;
}
inline const std::string& StreamIndexServiceResponseV1::_internal_index_code() const {
  return _impl_.index_code_.Get();
}
inline void StreamIndexServiceResponseV1::_internal_set_index_code(const std::string& value) {
  
  _impl_.index_code_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamIndexServiceResponseV1::_internal_mutable_index_code() {
  
  return _impl_.index_code_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamIndexServiceResponseV1::release_index_code() {
  // @@protoc_insertion_point(field_release:kaikosdk.StreamIndexServiceResponseV1.index_code)
  return _impl_.index_code_.Release();
}
inline void StreamIndexServiceResponseV1::set_allocated_index_code(std::string* index_code) {
  if (index_code != nullptr) {
    
  } else {
    
  }
  _impl_.index_code_.SetAllocated(index_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.index_code_.IsDefault()) {
    _impl_.index_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kaikosdk.StreamIndexServiceResponseV1.index_code)
}

// .kaikosdk.StreamIndexCommodity commodity = 2;
inline void StreamIndexServiceResponseV1::clear_commodity() {
  _impl_.commodity_ = 0;
}
inline ::kaikosdk::StreamIndexCommodity StreamIndexServiceResponseV1::_internal_commodity() const {
  return static_cast< ::kaikosdk::StreamIndexCommodity >(_impl_.commodity_);
}
inline ::kaikosdk::StreamIndexCommodity StreamIndexServiceResponseV1::commodity() const {
  // @@protoc_insertion_point(field_get:kaikosdk.StreamIndexServiceResponseV1.commodity)
  return _internal_commodity();
}
inline void StreamIndexServiceResponseV1::_internal_set_commodity(::kaikosdk::StreamIndexCommodity value) {
  
  _impl_.commodity_ = value;
}
inline void StreamIndexServiceResponseV1::set_commodity(::kaikosdk::StreamIndexCommodity value) {
  _internal_set_commodity(value);
  // @@protoc_insertion_point(field_set:kaikosdk.StreamIndexServiceResponseV1.commodity)
}

// .kaikosdk.DataInterval interval = 3;
inline bool StreamIndexServiceResponseV1::_internal_has_interval() const {
  return this != internal_default_instance() && _impl_.interval_ != nullptr;
}
inline bool StreamIndexServiceResponseV1::has_interval() const {
  return _internal_has_interval();
}
inline const ::kaikosdk::DataInterval& StreamIndexServiceResponseV1::_internal_interval() const {
  const ::kaikosdk::DataInterval* p = _impl_.interval_;
  return p != nullptr ? *p : reinterpret_cast<const ::kaikosdk::DataInterval&>(
      ::kaikosdk::_DataInterval_default_instance_);
}
inline const ::kaikosdk::DataInterval& StreamIndexServiceResponseV1::interval() const {
  // @@protoc_insertion_point(field_get:kaikosdk.StreamIndexServiceResponseV1.interval)
  return _internal_interval();
}
inline void StreamIndexServiceResponseV1::unsafe_arena_set_allocated_interval(
    ::kaikosdk::DataInterval* interval) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.interval_);
  }
  _impl_.interval_ = interval;
  if (interval) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kaikosdk.StreamIndexServiceResponseV1.interval)
}
inline ::kaikosdk::DataInterval* StreamIndexServiceResponseV1::release_interval() {
  
  ::kaikosdk::DataInterval* temp = _impl_.interval_;
  _impl_.interval_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kaikosdk::DataInterval* StreamIndexServiceResponseV1::unsafe_arena_release_interval() {
  // @@protoc_insertion_point(field_release:kaikosdk.StreamIndexServiceResponseV1.interval)
  
  ::kaikosdk::DataInterval* temp = _impl_.interval_;
  _impl_.interval_ = nullptr;
  return temp;
}
inline ::kaikosdk::DataInterval* StreamIndexServiceResponseV1::_internal_mutable_interval() {
  
  if (_impl_.interval_ == nullptr) {
    auto* p = CreateMaybeMessage<::kaikosdk::DataInterval>(GetArenaForAllocation());
    _impl_.interval_ = p;
  }
  return _impl_.interval_;
}
inline ::kaikosdk::DataInterval* StreamIndexServiceResponseV1::mutable_interval() {
  ::kaikosdk::DataInterval* _msg = _internal_mutable_interval();
  // @@protoc_insertion_point(field_mutable:kaikosdk.StreamIndexServiceResponseV1.interval)
  return _msg;
}
inline void StreamIndexServiceResponseV1::set_allocated_interval(::kaikosdk::DataInterval* interval) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.interval_);
  }
  if (interval) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(interval));
    if (message_arena != submessage_arena) {
      interval = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, interval, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.interval_ = interval;
  // @@protoc_insertion_point(field_set_allocated:kaikosdk.StreamIndexServiceResponseV1.interval)
}

// string quote = 4;
inline void StreamIndexServiceResponseV1::clear_quote() {
  _impl_.quote_.ClearToEmpty();
}
inline const std::string& StreamIndexServiceResponseV1::quote() const {
  // @@protoc_insertion_point(field_get:kaikosdk.StreamIndexServiceResponseV1.quote)
  return _internal_quote();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamIndexServiceResponseV1::set_quote(ArgT0&& arg0, ArgT... args) {
 
 _impl_.quote_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kaikosdk.StreamIndexServiceResponseV1.quote)
}
inline std::string* StreamIndexServiceResponseV1::mutable_quote() {
  std::string* _s = _internal_mutable_quote();
  // @@protoc_insertion_point(field_mutable:kaikosdk.StreamIndexServiceResponseV1.quote)
  return _s;
}
inline const std::string& StreamIndexServiceResponseV1::_internal_quote() const {
  return _impl_.quote_.Get();
}
inline void StreamIndexServiceResponseV1::_internal_set_quote(const std::string& value) {
  
  _impl_.quote_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamIndexServiceResponseV1::_internal_mutable_quote() {
  
  return _impl_.quote_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamIndexServiceResponseV1::release_quote() {
  // @@protoc_insertion_point(field_release:kaikosdk.StreamIndexServiceResponseV1.quote)
  return _impl_.quote_.Release();
}
inline void StreamIndexServiceResponseV1::set_allocated_quote(std::string* quote) {
  if (quote != nullptr) {
    
  } else {
    
  }
  _impl_.quote_.SetAllocated(quote, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.quote_.IsDefault()) {
    _impl_.quote_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kaikosdk.StreamIndexServiceResponseV1.quote)
}

// repeated .kaikosdk.StreamIndexServiceResponseBaseAsset bases = 5;
inline int StreamIndexServiceResponseV1::_internal_bases_size() const {
  return _impl_.bases_.size();
}
inline int StreamIndexServiceResponseV1::bases_size() const {
  return _internal_bases_size();
}
inline void StreamIndexServiceResponseV1::clear_bases() {
  _impl_.bases_.Clear();
}
inline ::kaikosdk::StreamIndexServiceResponseBaseAsset* StreamIndexServiceResponseV1::mutable_bases(int index) {
  // @@protoc_insertion_point(field_mutable:kaikosdk.StreamIndexServiceResponseV1.bases)
  return _impl_.bases_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kaikosdk::StreamIndexServiceResponseBaseAsset >*
StreamIndexServiceResponseV1::mutable_bases() {
  // @@protoc_insertion_point(field_mutable_list:kaikosdk.StreamIndexServiceResponseV1.bases)
  return &_impl_.bases_;
}
inline const ::kaikosdk::StreamIndexServiceResponseBaseAsset& StreamIndexServiceResponseV1::_internal_bases(int index) const {
  return _impl_.bases_.Get(index);
}
inline const ::kaikosdk::StreamIndexServiceResponseBaseAsset& StreamIndexServiceResponseV1::bases(int index) const {
  // @@protoc_insertion_point(field_get:kaikosdk.StreamIndexServiceResponseV1.bases)
  return _internal_bases(index);
}
inline ::kaikosdk::StreamIndexServiceResponseBaseAsset* StreamIndexServiceResponseV1::_internal_add_bases() {
  return _impl_.bases_.Add();
}
inline ::kaikosdk::StreamIndexServiceResponseBaseAsset* StreamIndexServiceResponseV1::add_bases() {
  ::kaikosdk::StreamIndexServiceResponseBaseAsset* _add = _internal_add_bases();
  // @@protoc_insertion_point(field_add:kaikosdk.StreamIndexServiceResponseV1.bases)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kaikosdk::StreamIndexServiceResponseBaseAsset >&
StreamIndexServiceResponseV1::bases() const {
  // @@protoc_insertion_point(field_list:kaikosdk.StreamIndexServiceResponseV1.bases)
  return _impl_.bases_;
}

// repeated string exchanges = 6;
inline int StreamIndexServiceResponseV1::_internal_exchanges_size() const {
  return _impl_.exchanges_.size();
}
inline int StreamIndexServiceResponseV1::exchanges_size() const {
  return _internal_exchanges_size();
}
inline void StreamIndexServiceResponseV1::clear_exchanges() {
  _impl_.exchanges_.Clear();
}
inline std::string* StreamIndexServiceResponseV1::add_exchanges() {
  std::string* _s = _internal_add_exchanges();
  // @@protoc_insertion_point(field_add_mutable:kaikosdk.StreamIndexServiceResponseV1.exchanges)
  return _s;
}
inline const std::string& StreamIndexServiceResponseV1::_internal_exchanges(int index) const {
  return _impl_.exchanges_.Get(index);
}
inline const std::string& StreamIndexServiceResponseV1::exchanges(int index) const {
  // @@protoc_insertion_point(field_get:kaikosdk.StreamIndexServiceResponseV1.exchanges)
  return _internal_exchanges(index);
}
inline std::string* StreamIndexServiceResponseV1::mutable_exchanges(int index) {
  // @@protoc_insertion_point(field_mutable:kaikosdk.StreamIndexServiceResponseV1.exchanges)
  return _impl_.exchanges_.Mutable(index);
}
inline void StreamIndexServiceResponseV1::set_exchanges(int index, const std::string& value) {
  _impl_.exchanges_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:kaikosdk.StreamIndexServiceResponseV1.exchanges)
}
inline void StreamIndexServiceResponseV1::set_exchanges(int index, std::string&& value) {
  _impl_.exchanges_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:kaikosdk.StreamIndexServiceResponseV1.exchanges)
}
inline void StreamIndexServiceResponseV1::set_exchanges(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.exchanges_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kaikosdk.StreamIndexServiceResponseV1.exchanges)
}
inline void StreamIndexServiceResponseV1::set_exchanges(int index, const char* value, size_t size) {
  _impl_.exchanges_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kaikosdk.StreamIndexServiceResponseV1.exchanges)
}
inline std::string* StreamIndexServiceResponseV1::_internal_add_exchanges() {
  return _impl_.exchanges_.Add();
}
inline void StreamIndexServiceResponseV1::add_exchanges(const std::string& value) {
  _impl_.exchanges_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kaikosdk.StreamIndexServiceResponseV1.exchanges)
}
inline void StreamIndexServiceResponseV1::add_exchanges(std::string&& value) {
  _impl_.exchanges_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kaikosdk.StreamIndexServiceResponseV1.exchanges)
}
inline void StreamIndexServiceResponseV1::add_exchanges(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.exchanges_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kaikosdk.StreamIndexServiceResponseV1.exchanges)
}
inline void StreamIndexServiceResponseV1::add_exchanges(const char* value, size_t size) {
  _impl_.exchanges_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kaikosdk.StreamIndexServiceResponseV1.exchanges)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamIndexServiceResponseV1::exchanges() const {
  // @@protoc_insertion_point(field_list:kaikosdk.StreamIndexServiceResponseV1.exchanges)
  return _impl_.exchanges_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StreamIndexServiceResponseV1::mutable_exchanges() {
  // @@protoc_insertion_point(field_mutable_list:kaikosdk.StreamIndexServiceResponseV1.exchanges)
  return &_impl_.exchanges_;
}

// repeated .kaikosdk.StreamIndexServiceResponsePercentage percentages = 7;
inline int StreamIndexServiceResponseV1::_internal_percentages_size() const {
  return _impl_.percentages_.size();
}
inline int StreamIndexServiceResponseV1::percentages_size() const {
  return _internal_percentages_size();
}
inline void StreamIndexServiceResponseV1::clear_percentages() {
  _impl_.percentages_.Clear();
}
inline ::kaikosdk::StreamIndexServiceResponsePercentage* StreamIndexServiceResponseV1::mutable_percentages(int index) {
  // @@protoc_insertion_point(field_mutable:kaikosdk.StreamIndexServiceResponseV1.percentages)
  return _impl_.percentages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kaikosdk::StreamIndexServiceResponsePercentage >*
StreamIndexServiceResponseV1::mutable_percentages() {
  // @@protoc_insertion_point(field_mutable_list:kaikosdk.StreamIndexServiceResponseV1.percentages)
  return &_impl_.percentages_;
}
inline const ::kaikosdk::StreamIndexServiceResponsePercentage& StreamIndexServiceResponseV1::_internal_percentages(int index) const {
  return _impl_.percentages_.Get(index);
}
inline const ::kaikosdk::StreamIndexServiceResponsePercentage& StreamIndexServiceResponseV1::percentages(int index) const {
  // @@protoc_insertion_point(field_get:kaikosdk.StreamIndexServiceResponseV1.percentages)
  return _internal_percentages(index);
}
inline ::kaikosdk::StreamIndexServiceResponsePercentage* StreamIndexServiceResponseV1::_internal_add_percentages() {
  return _impl_.percentages_.Add();
}
inline ::kaikosdk::StreamIndexServiceResponsePercentage* StreamIndexServiceResponseV1::add_percentages() {
  ::kaikosdk::StreamIndexServiceResponsePercentage* _add = _internal_add_percentages();
  // @@protoc_insertion_point(field_add:kaikosdk.StreamIndexServiceResponseV1.percentages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kaikosdk::StreamIndexServiceResponsePercentage >&
StreamIndexServiceResponseV1::percentages() const {
  // @@protoc_insertion_point(field_list:kaikosdk.StreamIndexServiceResponseV1.percentages)
  return _impl_.percentages_;
}

// .google.protobuf.Timestamp ts_event = 8;
inline bool StreamIndexServiceResponseV1::_internal_has_ts_event() const {
  return this != internal_default_instance() && _impl_.ts_event_ != nullptr;
}
inline bool StreamIndexServiceResponseV1::has_ts_event() const {
  return _internal_has_ts_event();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& StreamIndexServiceResponseV1::_internal_ts_event() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.ts_event_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& StreamIndexServiceResponseV1::ts_event() const {
  // @@protoc_insertion_point(field_get:kaikosdk.StreamIndexServiceResponseV1.ts_event)
  return _internal_ts_event();
}
inline void StreamIndexServiceResponseV1::unsafe_arena_set_allocated_ts_event(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* ts_event) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ts_event_);
  }
  _impl_.ts_event_ = ts_event;
  if (ts_event) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kaikosdk.StreamIndexServiceResponseV1.ts_event)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* StreamIndexServiceResponseV1::release_ts_event() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.ts_event_;
  _impl_.ts_event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* StreamIndexServiceResponseV1::unsafe_arena_release_ts_event() {
  // @@protoc_insertion_point(field_release:kaikosdk.StreamIndexServiceResponseV1.ts_event)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.ts_event_;
  _impl_.ts_event_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* StreamIndexServiceResponseV1::_internal_mutable_ts_event() {
  
  if (_impl_.ts_event_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.ts_event_ = p;
  }
  return _impl_.ts_event_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* StreamIndexServiceResponseV1::mutable_ts_event() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_ts_event();
  // @@protoc_insertion_point(field_mutable:kaikosdk.StreamIndexServiceResponseV1.ts_event)
  return _msg;
}
inline void StreamIndexServiceResponseV1::set_allocated_ts_event(::PROTOBUF_NAMESPACE_ID::Timestamp* ts_event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ts_event_);
  }
  if (ts_event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ts_event));
    if (message_arena != submessage_arena) {
      ts_event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ts_event, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ts_event_ = ts_event;
  // @@protoc_insertion_point(field_set_allocated:kaikosdk.StreamIndexServiceResponseV1.ts_event)
}

// string sequence_id = 9;
inline void StreamIndexServiceResponseV1::clear_sequence_id() {
  _impl_.sequence_id_.ClearToEmpty();
}
inline const std::string& StreamIndexServiceResponseV1::sequence_id() const {
  // @@protoc_insertion_point(field_get:kaikosdk.StreamIndexServiceResponseV1.sequence_id)
  return _internal_sequence_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamIndexServiceResponseV1::set_sequence_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sequence_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kaikosdk.StreamIndexServiceResponseV1.sequence_id)
}
inline std::string* StreamIndexServiceResponseV1::mutable_sequence_id() {
  std::string* _s = _internal_mutable_sequence_id();
  // @@protoc_insertion_point(field_mutable:kaikosdk.StreamIndexServiceResponseV1.sequence_id)
  return _s;
}
inline const std::string& StreamIndexServiceResponseV1::_internal_sequence_id() const {
  return _impl_.sequence_id_.Get();
}
inline void StreamIndexServiceResponseV1::_internal_set_sequence_id(const std::string& value) {
  
  _impl_.sequence_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamIndexServiceResponseV1::_internal_mutable_sequence_id() {
  
  return _impl_.sequence_id_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamIndexServiceResponseV1::release_sequence_id() {
  // @@protoc_insertion_point(field_release:kaikosdk.StreamIndexServiceResponseV1.sequence_id)
  return _impl_.sequence_id_.Release();
}
inline void StreamIndexServiceResponseV1::set_allocated_sequence_id(std::string* sequence_id) {
  if (sequence_id != nullptr) {
    
  } else {
    
  }
  _impl_.sequence_id_.SetAllocated(sequence_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sequence_id_.IsDefault()) {
    _impl_.sequence_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kaikosdk.StreamIndexServiceResponseV1.sequence_id)
}

// .google.protobuf.Timestamp last_ingest_time = 10;
inline bool StreamIndexServiceResponseV1::_internal_has_last_ingest_time() const {
  return this != internal_default_instance() && _impl_.last_ingest_time_ != nullptr;
}
inline bool StreamIndexServiceResponseV1::has_last_ingest_time() const {
  return _internal_has_last_ingest_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& StreamIndexServiceResponseV1::_internal_last_ingest_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.last_ingest_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& StreamIndexServiceResponseV1::last_ingest_time() const {
  // @@protoc_insertion_point(field_get:kaikosdk.StreamIndexServiceResponseV1.last_ingest_time)
  return _internal_last_ingest_time();
}
inline void StreamIndexServiceResponseV1::unsafe_arena_set_allocated_last_ingest_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_ingest_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_ingest_time_);
  }
  _impl_.last_ingest_time_ = last_ingest_time;
  if (last_ingest_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kaikosdk.StreamIndexServiceResponseV1.last_ingest_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* StreamIndexServiceResponseV1::release_last_ingest_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_ingest_time_;
  _impl_.last_ingest_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* StreamIndexServiceResponseV1::unsafe_arena_release_last_ingest_time() {
  // @@protoc_insertion_point(field_release:kaikosdk.StreamIndexServiceResponseV1.last_ingest_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_ingest_time_;
  _impl_.last_ingest_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* StreamIndexServiceResponseV1::_internal_mutable_last_ingest_time() {
  
  if (_impl_.last_ingest_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.last_ingest_time_ = p;
  }
  return _impl_.last_ingest_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* StreamIndexServiceResponseV1::mutable_last_ingest_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_ingest_time();
  // @@protoc_insertion_point(field_mutable:kaikosdk.StreamIndexServiceResponseV1.last_ingest_time)
  return _msg;
}
inline void StreamIndexServiceResponseV1::set_allocated_last_ingest_time(::PROTOBUF_NAMESPACE_ID::Timestamp* last_ingest_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_ingest_time_);
  }
  if (last_ingest_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_ingest_time));
    if (message_arena != submessage_arena) {
      last_ingest_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_ingest_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.last_ingest_time_ = last_ingest_time;
  // @@protoc_insertion_point(field_set_allocated:kaikosdk.StreamIndexServiceResponseV1.last_ingest_time)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace kaikosdk

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_sdk_2fstream_2findex_5fv1_2fresponse_2eproto
